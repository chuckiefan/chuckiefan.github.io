<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	【翻译】安卓架构组件(7)-分页库 - Chuckiefan's Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Chuckiefan's Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">Chuckiefan's Blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">【翻译】安卓架构组件(7)-分页库</h1>
		<div class="entry-content" itemprop="articleBody">
			<p>相关文章：</p>

<ul>
<li><a href="http://chuckiefan.com/2017/06/07/%E7%BF%BB%E8%AF%91-%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6(1)-App%E6%9E%B6%E6%9E%84%E6%8C%87%E5%AF%BC.html">【翻译】安卓架构组件(1)-App架构指导</a></li>
<li><a href="http://chuckiefan.com/2017/06/07/%E7%BF%BB%E8%AF%91-%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6(2)-%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6%E5%88%B0%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD.html">【翻译】安卓架构组件(2)-添加组件到你的项目中</a></li>
<li><a href="http://chuckiefan.com/2017/06/07/%E7%BF%BB%E8%AF%91-%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6(3)-%E5%A4%84%E7%90%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html">【翻译】安卓架构组件(3)-处理生命周期</a></li>
<li><a href="http://chuckiefan.com/2017/06/07/%E7%BF%BB%E8%AF%91-%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6(4)-LiveData.html">【翻译】安卓架构组件(4)-LiveData</a></li>
<li><a href="http://chuckiefan.com/2017/06/07/%E7%BF%BB%E8%AF%91-%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6(5)-ViewModel.html">【翻译】安卓架构组件(5)-ViewModel</a></li>
<li><a href="http://chuckiefan.com/2017/06/07/%E7%BF%BB%E8%AF%91-%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6(6)-Room%E6%8C%81%E4%B9%85%E5%8C%96%E7%B1%BB%E5%BA%93.html">【翻译】安卓架构组件(6)-Room持久化类库</a></li>
</ul>

<p>分页库使你的app能够在需要从一个数据源逐步加载数据时更为轻松，避免了过度加载以及为了一个大型数据的查询等待太多时间。</p>

<h2 id="toc_0">综述</h2>

<p>许多app伴随着大量的数据，但是在任意时刻往往只需要加载和显示其中的一小部分。一个app可能存在数以万计的数据以供显示，但在某一时刻仅仅需要访问其中的几十条。如果app没有认真处理这个这个问题，会请求实际上并不需要的数据，并导致不必要的性能负担和网络带宽。如果数据并没有被存储起来或同步到远程数据库，这同样会减慢app的运行速度以及浪费用户的流量。</p>

<p>当然现有的安卓API允许对内容进行分页，它们伴有明显的约束和缺点：</p>

<ul>
<li><code>CursorAdapter</code>使得将数据库查询结果映射到<code>ListView</code>列表项更为轻松，但它会在UI线程执行数据库查询，并且使用<code>Cursor</code>的分页并不高效。对于使用<code>CursorAdapter</code>的更多缺陷，请查询<a href="https://medium.com/google-developers/large-database-queries-on-android-cb043ae626e8">这里</a>。</li>
<li><code>AsyncListUtil</code>允许将基于位置的分页数据加载至<code>RecyclerView</code>，但是并不允许无位置的分页，而且它会强迫使用空白占用位。</li>
</ul>

<p>新的分页库致力于解决这些问题。这个类库包含一些类，以流水线的方式处理你所需数据的请求过程。这些类也可以和已经存在的架构类组件无缝结合，如<code>Room</code>。</p>

<h2 id="toc_1">类</h2>

<p>分页库提供以下的类以及额外的支持类：</p>

<h3 id="toc_2"><code>DataSource</code></h3>

<p>使用这个类定义一个你用来分页拉取的数据源。根据如何访问你的数据，你可以集成以下两个子类之一：</p>

<ul>
<li><code>KeyedDataSource</code> 如果你需要从第N个数据项获取第N+1个数据项。例如，如果你的线程在一个讨论的app获取评论，你可能需要传递一个评论的id来获取下一个评论。</li>
<li><code>TiledDataSource</code> 如果你需要从你的数据源中获取任意指定位置的分页数据。这个类支持从你选择的任何位置请求数据，例如：“返回从位置1200开始的20条数据”。</li>
</ul>

<p>如果你使用<code>Room</code>来管理你的数据，它会自动创建一个<code>TiledDataSource</code>，例如：</p>

<pre><code class="language-java">@Query(&quot;select * from users WHERE age &gt; :age order by name DESC, id ASC&quot;)
TiledDataSource&lt;User&gt; usersOlderThan(int age);
</code></pre>

<h3 id="toc_3"><code>PagedList</code></h3>

<p>这个类从<code>DataSource</code>加载数据。你可以配置在任何时刻该获取多少数据，以及需要预加载多少数据，以最小化用户等待数据被加载时等待的时间。这个类可以给其他类提供更新信号，例如<code>RecyclerView.Adapter</code>，允许当数据分页加载时更新你的<code>RecyclerView</code>。</p>

<h3 id="toc_4"><code>PagedListAdapter</code></h3>

<p>这个类是<code>RecyclerView.Adapter</code>的子类，使得数据从<code>PagedList</code>中展现。例如，当新的一页数据被加载时，<code>PagedListAdapter</code>通知<code>RecyclerView</code>数据已经到达，这让<code>RecyclerView</code>替换任何占位项，并展示合适的动画效果。</p>

<p><code>PagedListAdapter</code>使用后台线程计算从一个<code>PagedList</code>到另一个的变化（例如，当数据库的变更导致数据的更新），并调用<code>notifyItem...()</code>方法，并在需要时更新列表数据内容。之后<code>RecyclerView</code>展现必要的变化。例如，当一个数据项在不同的<code>PagedList</code>版本间变更位置时，<code>RecyclerView</code>动画会展示数据项移动到新的位置。</p>

<h3 id="toc_5"><code>LivePagedListProvider</code></h3>

<p>这个生成从你提供的<code>DataSource</code>生成一个<code>LiveData&lt;PagedList&gt;</code>。此外，如果你使用<code>Room</code>持久化类库来管理你的数据库，DAO可以使用<code>TiledDataSource</code>生成<code>LivePagedListProvider</code>，例如：</p>

<pre><code class="language-java">@Query(&quot;SELECT * from users order WHERE age &gt; :age order by name DESC, id ASC&quot;)
public abstract LivePagedListProvider&lt;Integer, User&gt; usersOlderThan(int age);
</code></pre>

<blockquote>
<p><code>Integer</code>参数告知Room基于位置加载的<code>TiledDataSource</code>。</p>
</blockquote>

<p>分页库组件在后台线程组织了数据流，并在UI线程展示。例如：当一个新的数据项被插入到你的数据库时，<code>DataSource</code>会失效， 后台线程产生一个新的<code>PagedList</code>。</p>

<p><img src="http://ourmc2t8i.bkt.clouddn.com/15102822354339.gif" alt="图1 分页库组件在后台线程执行大部分工作，因此并不会影响UI线程"/></p>

<p>新创建的<code>PagedList</code>在UI线程被发送到<code>PagedListAdapter</code>。之后<code>PagedListAdapter</code>使用<code>DiffUtil</code>在后台线程计算当前列表和新列表的不同。当比较结束时，<code>PagedListAdapter</code>使用比较得到的差异信息适当地调用<code>RecyclerView.Adapter.notifyItemInserted()</code>来通知新的数据项被插入。</p>

<p><code>RecyclerView</code>在UI线程知道仅仅需要绑定一个新的数据项，并使用动画展示在屏幕上。</p>

<p>下面的代码示例显示了所有相关部分的工作。当数据库添加、删除或者更新时，<code>RecyclerView</code>的内容自动且高效地更新：</p>

<pre><code class="language-java">@Dao
interface UserDao {
    @Query(&quot;SELECT * FROM user ORDER BY lastName ASC&quot;)
    public abstract LivePagedListProvider&lt;Integer, User&gt; usersByLastName();
}

class MyViewModel extends ViewModel {
    public final LiveData&lt;PagedList&lt;User&gt;&gt; usersList;
    public MyViewModel(UserDao userDao) {
        usersList = userDao.usersByLastName().create(
                /* 初始化加载位置 */ 0,
                new PagedList.Config.Builder()
                        .setPageSize(50)
                        .setPrefetchDistance(50)
                        .build());
    }
}

class MyActivity extends AppCompatActivity {
    @Override
    public void onCreate(Bundle savedState) {
        super.onCreate(savedState);
        MyViewModel viewModel = ViewModelProviders.of(this).get(MyViewModel.class);
        RecyclerView recyclerView = findViewById(R.id.user_list);
        UserAdapter&lt;User&gt; adapter = new UserAdapter();
        viewModel.usersList.observe(this, pagedList -&gt; adapter.setList(pagedList));
        recyclerView.setAdapter(adapter);
    }
}

class UserAdapter extends PagedListAdapter&lt;User, UserViewHolder&gt; {
    public UserAdapter() {
        super(DIFF_CALLBACK);
    }
    @Override
    public void onBindViewHolder(UserViewHolder holder, int position) {
        User user = getItem(position);
        if (user != null) {
            holder.bindTo(user);
        } else {
            // NULL时定义了一个占位项——当实际的对象被从数据库加载时，PagedListAdapter会自动失效该行
            holder.clear();
        }
    }
    public static final DiffCallback&lt;User&gt; DIFF_CALLBACK = new DiffCallback&lt;User&gt;() {
        @Override
        public boolean areItemsTheSame(@NonNull User oldUser, @NonNull User newUser) {
            // 用户属性可能会在重新加载时变化，但id是固定的。
            return oldUser.getId() == newUser.getId();
        }
        @Override
        public boolean areContentsTheSame(@NonNull User oldUser, @NonNull User newUser) {
            // 注意：如果你使用equals，你的对象会重载Object.equals()方法
            // 如果不正确地返回false会导致许多动画效果
            return oldUser.equals(newUser);
        }
    }
}
</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>